16. 附录-不同模式的功能性概述
==============================

16.1 第一阶段(前4个部分)
-------------------------

第一步,可以用点按钮的方式引导Karel

- go ... 向前走一步
- left ... 左转
- right ... 右转
- get ... 拾起一枚宝石
- put ... 放下一枚宝石

16.2 编程模式(5-15部分)
------------------------

在编程模式中,Karel有如下功能:

- go ... 向前走一步
- left ... 左转
- right ... 右转
- put ... 放下一枚宝石
- get ... 拾起一枚宝石
- repeat ... 计数循环(重复给定次数的操作)
- if/else ... 条件判断
- while ... 条件循环(重复某操作直到满足某条件)
- def ... 定义一个新的命令
- wall ... 检测机器人前方是否有墙
- gem ... 检测机器人正下方是否有宝石
- tray ... 检测机器人正下方是否有托盘
- empty ... 检测机器人的包里是否没有宝石
- home ... 检测机器人是否在家方块
- north ... 检测机器人是否面朝北
- print ... 打印字符串和变量
- gpsx ... 水平方向的GPS坐标
- gpsy ... 垂直方向的GPS坐标
- a = 0 ... 创建一个变量 *a* 并实例化为0
			更多实例化方法参考 :doc:`11.8节<p11>`
- inc(a) ... 增加变量 *a* 的值一个单位
- inc(a,value) ... 增加变量 *a* 的值 *value* 个单位
- dec(a) ... 减少变量 *a* 的值一个单位
- dec(a,value) ... 减少变量 *a* 的值 *value* 个单位
- rand ... 随机命令(随机返回 ``True`` 或 ``False``)
- return ... 返回一个值,在函数中使用
- and ... 二元逻辑运算 ``and``
- or ... 二元逻辑运算 ``or``
- not ... 一元逻辑运算 ``not``
- L[] ... 创建空列表 *L* 
- len(L) ... 列表 *L* 的长度
- L[i] ... 列表 *L* 的第 *i+1* 个元素.注:L[0]是列表的第一个元素
- L.append(x) ... 将 *x* 扩展到列表 *L* 的结尾
- x = L.pop() ... 删除列表 *L* 的最后一个元素并赋值给变量 *x*
- del L[i] ... 删除列表 *L* 的第i个元素
- for x in L ... 以Python的方式分析列表.
- 数值和布尔(逻辑)变量
- 复杂逻辑表达
- 返回值的函数
- 列表
- 递归


17. 进一步学习
===============

祝贺你,你已经完成了Karel机器人!希望你喜欢这个课程.如果你希望改进此应用或教材,我们愿意倾听.
如果你有一个新的游戏或Karel的练习,请告知我们:-)

现在你已经为学习下一个编程语言做好了准备!我们建议你学习Python,它是被广泛使用的动态编程语言,
如商业,科学,工程和其他领域.我们同样提供精致的Python课程.

无论如何,我们的团队希望你好运,希望成为你最爱的书签!

												你的作者. 
